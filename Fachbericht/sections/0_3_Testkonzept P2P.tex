\vspace*{4cm}
\begin{center}
\part{Point to Point Testinfrastruktur}\label{part:PointtoPointTestinfrastruktur}
\end{center}
\vspace*{\fill}
\clearpage

\section{Messkonzept}\label{sec:KonzeptP2PMessung}
In den nachfolgenden Abschnitten wird auf die Kon­zep­ti­o­nie­rung und Umsetzung der Point to Point (P2P) Testinfrastruktur eingegangen.
Ziel dieser Infrastruktur ist, die Verbindungen auf den MAC-Layern \textit{BLE} sowie \textit{IEEE 802.15.4} auszumessen.
Die Mac-Layer Verbindung beschreibt eine rudimentäre Kommunikation zwischen zwei Knoten, welche direkt auf der physikalischen Schicht stattfindet und keine Netzwerk- und Applikationsschichten daran beteiligt sind.
Dazu wird zuerst das Messkonzept präsentiert und anschliessend die Inbetriebnahme und Bedienung der Messinfrastruktur erläutert. Schliesslich werden noch die technischen Einzelheiten hinsichtlich der Umsetzung dargelegt.

\subsection{Definition MAC-Layer}\label{sec:MAC-LayerP2P}
Der MAC-Layer ist bei Protokollen für die drahtlose Kommunikation oftmals über Normen spezifiziert. Die eingesetzte Hardware-Plattform (siehe Abschnitt \ref{sec:HardwarePlattform}) unterstützt \textit{BLE} sowie den \textit{IEEE 802.15.4} Standard.
Diese beiden Standards werden im Weiteren als Radio-Mode bezeichnet. Nebst dem Radio-Mode charakterisiert sich die MAC-Schicht über den verwendeten Kanal. Dabei handelt es sich um das Frequenzband, auf welchem gesendet wird. 

\subsection{Anforderungen}\label{subsec:AnforderungenP2P}

Die Anforderung an die Point-to-Point Testinfrastruktur ist, eine Verbindung zwischen zwei Funkmodulen anhand der folgenden Messwerte charakterisieren zu können:

\begin{itemize}
	\item \textit{\textbf{Signal to Noise Ratio (SNR)}}
	\item \textit{\textbf{Packetloss}}
\end{itemize}

Das Ausmessen der obigen Eigenschaften soll pro Kanal möglich sein. Die folgenden Parameter müssen vom Benutzer eingestellt werden können, um eine Messung durchzuführen:

\begin{itemize}
	\item \textit{\textbf{Radio-Mode}} BLE-1Mbit oder IEEE 802.15.4
	\item \textit{\textbf{Start-Channel:}} Der Start-Channel definiert den Kanal, auf welchem die Messung gestartet werden soll. Dieser ist abhängig vom Radio-Mode.
	\item \textit{\textbf{Stop-Channel:}} Der Stop-Channel definiert den Kanal, bis zu welchem die Messung durchgeführt werden soll. Dieser ist ebenfalls abhängig vom Radio-Mode.
	\item \textit{\textbf{Tx-Power:}} Sendeleistung beim Versand der Testnachrichten.
	\item \textit{\textbf{Collision-Avoidance (CA):}} Kollisionsvermeidung (nur bei IEEE 802.15.4 Radio Mode)
	\item \textit{\textbf{Payload:}} Anzahl der zu sendenden Bytes pro Paket.
\end{itemize}


\subsection{Messgrössen}\label{subsec:MessgrössenP2P}
Wie bereits in Abschnitt \ref{subsec:AnforderungenP2P} erwähnt, wird das Signal-Rausch-Verhältnis (SNR) und der Paketverlust gemessen. Die beiden Messgrössen können mit Hilfe der nRF-Plattform direkt bestimmt werden.

\begin{itemize}
	\item \textbf{\textit{SNR}}: Gibt das Verhältnis zwischen der Signalleistung und Rauschleistung an. Als Rauschen werden jegliche Umwelteinflüsse (Störungen) bezeichnet. Zur Bestimmung des SNR muss die Rauschleistung und Signalleistung erfasst werden.
	Bei der Detektion der Rauschleistung muss der Signalbringer (Sender) deaktiviert sein. Das Messen der Signalleistung inkl. Rauschleistung erfolgt hingegen bei eingeschaltetem Sender.
	
	\item \textbf{\textit{Paketverlust}}: Als Paketverlust wird das Verhältnis zwischen der Anzahl Pakete bezeichnet, die das Ziel nicht erreicht haben, zu der totalen Anzahl versendeten Pakete.
	Zur Bestimmung dieses Verhältnisses werden Pakete generiert und vom Sender zum Empfänger übermittelt. Dieser zählt die Anzahl empfangener Pakete und meldet den Zählwert dem Sender zurück. Damit ist der Sender in der Lage, den Paketverlust zu berechnen. 
\end{itemize} 


\subsection{Konzept}\label{sec:KonzeptP2P}
Zur Realisierung der Point to Point Testinfrastruktur wurde auf ein \textit{One to Many} (1:n) Messprinzip gesetzt (auch als Multicast bezeichnet). Dies hat den Vorteil, dass mehrere Verbindungen gleichzeitig ausgemessen werden können. Der Nachteil dabei ist, dass so die Messpfade nur unidirektional charakterisiert werden (nur von Master zu Slave oder Uplink-Pfad). Die Abweichung zwischen Up- und Downlink Pfad kann durch die Wiederholung der Messung mit vertauschten Standorten verifiziert werden. 

\begin{figure} [H]
	\centering
	\includegraphics[width=0.7\textwidth]{Konzeptschema_P2P.png}
	\caption{Konzeptschema P2P Testinfrastruktur}
	\label{fig:KonzeptschemaP2P}
\end{figure}


Das in Abbildung \ref{fig:KonzeptschemaP2P} gezeigte Konzept besteht aus einer Management Station, einem Master- und mehreren Slave Nodes.
Über die Management Station können Messresultate angezeigt sowie Messparameter eingestellt werden. Als Ausgangspunkt zur Messung dient der MN (Master Node).
Er koordiniert den Messablauf und sendet \textit{Probe Packets} an alle SN (Slave Nodes).
Diese protokollieren die Anzahl empfangener \textit{Probe Packets} und melden ihre Messresultate an den MN zurück.
Nach Empfang aller Resultate leitet der MN alle Messergebnisse an die MS weiter.
Dort werden dem Benutzer die Messdaten dargestellt.
Details zum Ablauf sind in Abschnitt \ref{sec:SoftundFirmware} aufgeführt.
Eine mögliche Anwendung der Testinfrastruktur wird im nachfolgenden Abschnitt \ref{sec:TestszenarienP2P} beschrieben.  

\subsection{Testszenarien}\label{sec:TestszenarienP2P}
Die P2P Testinfrastruktur ist als einfach zu bedienendes Tool konzipiert.
Es kann eingesetzt werden, um den Aufbau von sogenannten \textit{Wireless Personal Area Networks (WPAN)} zu optimieren.
Mithilfe dieses Tools können zum Beispiel die Standorte der Teilnehmer eines Zigbee, Thread oder Bluetooth Mesh Netzwerks optimal gewählt werden.

Weiter kann die Testinfrastruktur als Störquelle in den Benchmarks von Mesh Netzwerken eingesetzt werden (siehe Abschnitt \ref{sec:BenchmarkKonzeptMeshNetzwerke}).
Die Form der Störung kann dabei gemäss den einstellbaren Parametern aus Abschnitt \ref{subsec:AnforderungenP2P} frei gewählt werden.

\subsection{Messaufbau}\label{sec:Messaufbau}
Bei der verwendeten Hardware handelt es sich um einen nRF52840 Mikrocontroller (siehe auch Abschnitt \ref{sec:HardwarePlattform}).
Als Master dient das Development-Kit (DK), welches über eine USB-Buchse verfügt.
Als Slaves kommen sowohl DKs als auch die USB-Dongle Variante in Frage.
Letztere sind einfacher unterzubringen und werden in diesem Messaufbau bevorzugt.
Um die erhaltenen Daten auswerten zu können, geschieht die Visualisierung mittels einem Laptop oder PC.
Dieser muss mit der USB Buchse des Masters verbunden werden und die entsprechende Auswertesoftware gestartet sein.
Im nachfolgenden Abschnitt \ref{sec:InbetriebnahmeBedienungP2P} wird die Inbetriebnahme und die Bedienung der P2P-Testinfrastruktur genauer beschrieben.
Die Abbildung \ref{fig:MessaufbauP2P} zeigt den schematischen Messaufbau der P2P-Testinfrastruktur. Der Master kann durch den Einsatz eines Notebooks mobil gehalten werden, um so den optimalen Standort des Masters auszuloten.
Die Slaves werden in der Wohnung oder im Haus an den möglichen Standorten der Mesh Nodes platziert. Danach wird die Messung gestartet.

\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\textwidth]{Messaufbau_P2P.png}
	\caption{Messaufbau P2P Testinfrastruktur}
	\label{fig:MessaufbauP2P}
\end{figure}


\newpage
\section{Inbetriebnahme und Bedienung}\label{sec:InbetriebnahmeBedienungP2P}
Die P2P Testinfrastruktur kann von jedem interessierten Anwender eingesetzt werden.
Zur Inbetriebnahme müssen jedoch folgende Hard- und Software Komponenten vorhanden und einsatzbereit sein: 

\begin{itemize}
	\item 1x nRF52840 DK (Master)
	\item 1x nRF52840 DK / Dongle (Slave)
	\item Laptop mit folgender Software:
	\begin{itemize}
		\item Python 3.x
		\item nrfutil (pip install nrfutil), zum Flashen der nRF52840.
		\item Browser, zur Darstellung der Weboberfläche
	\end{itemize}
\end{itemize}

Eine Anleitung und der Sourcecode sind im \href{https://github.com/Rouben94/P6_Software}{Github-Repository\footnote{\url{https://github.com/Rouben94/P6_Software}\cite{github_p6_software_p2p_2020}}} zu diesem Projekt verfügbar.
Master und Slaves sind mit der entsprechenden Firmware zu laden um diese für die Messung vorzubereiten.
Anschliessend werden die Slaves im Raum platziert und der Master am Laptop eingesteckt.
Nach erfolgtem Setup ist gemäss den nachfolgend beschriebenen Schritten vorzugehen.

\paragraph{Schritt 1 - Webserver Starten}
Der Webserver wurde mit einer Windows Umgebung entwickelt und getestet. Die folgende Anleitung ist demzufolge nur für eine Windows Umgebung gültig.
Für die Verwendung mit Linux oder MacOS sind unter folgendem \href{https://tutorial.djangogirls.org/en/django_installation}{Link\footnote{\url{https://tutorial.djangogirls.org/en/django_installation/}}} entsprechende Anleitungen verfügbar.
Bevor der Webserver gestartet werden kann, muss der Sourcecode vom \href{https://github.com/Rouben94/P6_Software}{Github-Repository\footnotemark[1]} geklont werden.
Auf der Ordnerebene \textbf{P6\_Software\textbackslash P2P\textbackslash Webserver\textbackslash p2p\_webserver} müssen folgende cmd Befehle ausgeführt werden.

\begin{lstlisting}[style=DOS]
Microsoft Windows [Version 10.0.18363.1016]
(c) 2019 Microsoft Corporation. Alle Rechte vorbehalten.

C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> .\myvenv\Scripts\activate
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> python .\manage.py runserver
Performing system checks...
	
System check identified no issues (0 silenced).
August 20, 2020 - 22:01:13
Django version 3.0.8, using settings 'p2p_site.settings'
Starting development server at http://127.0.0.1:8000/   
Quit the server with CTRL-BREAK.
\end{lstlisting}


Sobald dies erfolgreich ausgeführt wurde, ist der Webserver gestartet und kann unter der Adresse \textbf{http://127.0.0.1:8000/} erreicht werden.

\newpage
Falls das Starten nicht geklappt hat, müssen möglicherweise Django und die benötigten Python Bibliotheken nachinstalliert werden. Dies wird wie folgt gemacht:

\begin{lstlisting}[style=DOS]
Microsoft Windows [Version 10.0.18363.1016]
(c) 2019 Microsoft Corporation. Alle Rechte vorbehalten.

C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> .\myvenv\Scripts\activate
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> pip install Django==3.1
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> pip install pyserial
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> pip install plotly
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> python manage.py makemigrations p2p
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> python manage.py migrate p2p
(myvenv) C:\Users\GitHub\P6_Software\P2P\Webserver\p2p_webserver> python .\manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).
August 20, 2020 - 22:01:13
Django version 3.0.8, using settings 'p2p_site.settings'
Starting development server at http://127.0.0.1:8000/   
Quit the server with CTRL-BREAK.
\end{lstlisting}

\paragraph{Schritt 2 - Verbindungsaufbau}
Sobald der Webserver gestartet wurde, ist die Seite \textbf{Point to Point} zu sehen (siehe Abbildung \ref{fig:WebserverNodelistViewausgeklappt}). Wie in der Abbildung beschrieben, muss nun auf die Seite Connection gewechselt werden, damit die Verbindung zum Master aufgenommen werden kann. Es besteht die Möglichkeit das Hauptmenü auf der linken Seite auf und zu zuklappen (siehe Nummer 1 in Abbildung \ref{fig:WebserverNodelistViewausgeklappt}). Wenn das Hauptmenü aufgeklappt ist, kann das Github-Repository durch einen Klick auf die Schaltfläche \textbf{GitHub Repo} erreicht werden.
\begin{figure} [H]
	\centering
	\includegraphics[width=\textwidth]{Webserver_nodelist_ausgeklappt.png}
	\caption{Webserver Nodelist View ausgeklappt}
	\label{fig:WebserverNodelistViewausgeklappt}
\end{figure}

\newpage
Auf der Seite \textbf{Connection} (siehe Abbildung \ref{fig:WebserverConnectionView}) soll für die Kommunikation mit der Seriellen Schnittstelle der entsprechende COM-Port, an dem der Master registriert ist, ausgewählt werden (siehe Nummer 1 in Abbildung \ref{fig:WebserverConnectionView}). Mit einem Klick auf das Feld \textbf{Connect} wird nun eine Verbindung hergestellt (siehe Nummer 2 in Abbildung \ref{fig:WebserverConnectionView}). Falls der Master nicht angeschlossen oder auf einem anderen COM-Port registriert ist, wird dies mit einer Fehlermeldung mitgeteilt.
\begin{figure} [H]
	\centering
	\includegraphics[width=0.6\textwidth]{Webserver_Connection.png}
	\caption{Webserver Connection View}
	\label{fig:WebserverConnectionView}
\end{figure}

\paragraph{Schritt 3 - Einstellen der Parameter}
Nachdem die Serielle Verbindung zum Master hergestellt ist, werden auf der Seite \textbf{Point to Point} die verfügbaren Slaves in der Tabelle aufgeführt. Die Tabelle aktualisiert sich automatisch. Wie in der Abbildung \ref{fig:WebserverNodelistView} ersichtlich, sind die Nodes anhand der MAC-Adresse identifizierbar. Die Tabelle zeigt die dazugehörigen Channels, welche zuvor eingestellt wurden. Pro Channel ist ein Wert für den Packetloss und den SNR zu sehen. Die Definition dieser Werte ist im Abschnitt \ref{subsec:MessgrössenP2P} beschrieben. 

Damit die Parameter der Nodes verändert werden können, besteht auf der gleichen Seite die Möglichkeit, die gewünschten Werte einzugeben und an den Master zu senden. Die Parameter können, wie in Abbildung \ref{fig:WebserverNodelistView} markiert, definiert werden. Folgende Vorgaben müssen bei der Eingabe eingehalten werden:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|} 
\hline
\textbf{Radio Mode} & \textbf{IEEE 802.15.4 250 kBit}  & \textbf{Alle Anderen Modi}  \\ 
\hline
\textbf{Start Channel Feld} & 11 & 0 \\ 
\hline
\textbf{Stop Channel Feld} & 26 & 39 \\ 
\hline
\textbf{Payload Feld} & 0 - 120 bit & 0 - 250 bit \\
\hline
\end{tabular}
\caption{Zulässige Parameter für die Eingabefelder in der Nodelist View}
\label{tab:ParameterEingabefelederNodelistView}
\end{table}


\begin{figure} [H]
	\centering
	\includegraphics[width=\textwidth]{Webserver_Nodelist.png}
	\caption{Webserver Nodelist View}
	\label{fig:WebserverNodelistView}
\end{figure}

\paragraph{Schritt 4 - Vergleich der Channels}
Damit die Channels von einem Node besser miteinander verglichen werden können, ist auf der Seite \textbf{Chart} eine entsprechende Grafik verfügbar.
Jeder Node wird in einem separaten aufklappbaren Fenster angezeigt.
In Abbildung \ref{fig:WebserverChartView} mit der Nummer \textbf{1.} gekennzeichnet, ist ein solches Fenster zu sehen.
Mit Klick auf die Schaltfläche mit der Nummer \textbf{1.} wird das Fenster aufgeklappt und alle eingestellten Channels werden nacheinander mit dem Packetloss in \% aufgelistet.
\begin{figure} [H]
	\centering
	\includegraphics[width=\textwidth]{Webserver_Chart.png}
	\caption{Webserver Chart View}
	\label{fig:WebserverChartView}
\end{figure}

\newpage
\section{Soft- und Firmware}\label{sec:P2PSoft-undFirmware}
In den nachfolgenden Abschnitten wird die Soft- und Firmware für die P2P Testinfrastruktur beschrieben.
Der dazugehörige Sourcecode ist im \href{https://github.com/Rouben94/P6_Software}{Github-Repository\footnote{\url{https://github.com/Rouben94/P6_Software}\cite{github_p6_software_p2p_2020}}} zu diesem Projekt frei zugänglich und kann für die vertiefte Untersuchung konsultiert werden.

\subsection{Soft- und Firmware}\label{sec:SoftundFirmware}
Die Firmware ist als zeitabhängige Schrittkette aufgebaut.
Jeder Schritt ist über ein fixes Zeitfenster definiert.
Damit alle Teilnehmer synchron die Schrittkette abarbeiten können, muss mit Hilfe einer Zeitsynchronisation auf den Master der exakte Startzeitpunkt kommuniziert werden.
Unabhängig vom Zustand des aktiven Schrittes darf dieser sein Zeitfenster nicht überschreiten, ansonsten fällt die Schrittkette aus dem Takt. 

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{Software_Flowgraph_P2P.png}
	\caption{Schrittkette P2P Testinfrastruktur}
	\label{fig:FlowgraphP2P}
\end{figure}

Abbildung \ref{fig:FlowgraphP2P} zeigt die Schrittkette für den Master, sowie für die Slave-Nodes.
Der Ablauf zeigt die Schritte, sowie die Bedingungen der Transitionen zwischen den Schritten.
Jedoch muss beachtet werden, dass jeder Schritt immer während einer bestimmten Zeit aktiv bleibt.
Somit ist ersichtlich dass der \textit{Packets-State} nach Ablauf seines Zeitfensters immer zum \textit{ReportsReq-State} führt.
Dabei hängt der Wechsel nach dem \textit{Discovery-State} von verschiedenen Bedingungen ab.

Auf die Funktion der Schritte wird nachfolgend kurz eingegangen: 

\begin{itemize}
	\item \textbf{\textit{Discovery:}} Der Master verteilt die Zeitsynchronisation an die Slaves. Die Slaves synchronisieren sich auf das Signal des Masters auf, sofern sie in seiner Reichweite liegen. Hat ein Slave sich nicht synchronisieren können, verweilt dieser im \textit{Discovery-State}. Der Master kann in jedem Fall zum nächsten Schritt voranschreiten.
	 
	\item \textbf{\textit{Mockup:}} Der Master wartet auf eine Antwort der einzelnen Slaves. Jeder Slave generiert einen zufälligen Timeslot, um sich beim Master anzumelden. Der Master führt alle Slaves, die sich gemeldet haben, in einer Liste auf. Hat sich kein Slave gemeldet, ist diese Liste leer und der Master wird zum \textit{Discovery State} zurückkehren. Ist ein Slave bereits beim Master angemeldet, so muss er sich nicht erneut anmelden. 
	
	\item \textbf{\textit{Param:}} Der Master versendet die Packets-Parameter (Mode, StartChannel, StopChannel, etc.). Erhält ein Slave keine Daten, so kehrt er in den \textit{Discovery-State} zurück. 
	
	\item \textbf{\textit{Packets:}} Der Master versendet \textit{Probe Packets} mit den zuvor kommunizierten Einstellungen. Die Slaves empfangen diese Daten, zählen die Anzahl erfolgreich empfangener Pakete und erfassen weitere Messdaten. 
	\item  \textbf{\textit{Reports Req:}} Nach dem Ausmessen beginnt der Master mit dem Einsammeln der einzelnen Slave Reports. Dazu sendet er an jeden Slave in seiner Liste (aus dem \textit{Mockup-State}) Report-Anfragen, sogenannte \textit{Report-Requests}. Die Slaves warten auf einen \textit{Report Request} vom Master. 
	
	\item  \textbf{\textit{Reports:}} Der Slave, welcher den Request erhalten hat, sendet seinen Report zum Master. Dies hat innerhalb einer gewissen Zeit zu erfolgen. Sendet ein Slave nach einer gewissen Anzahl von Versuchen innerhalb dieser begrenzten Zeit keine Reports, so wird er aus der Liste der gemeldeten Slaves entfernt. Sobald der Master alle Reports von allen Slaves empfangen hat, meldet er an alle Slaves über eine spezielle \textit{Reports-Request-Message}, dass das Reporting beendet ist.
	
	\item  \textbf{\textit{Publish:}} Im \textit{Publishing-State} hat der Master Zeit, die Daten an die übergeordnete Stelle zu übermitteln (USB-UART). Die Slaves können in diesem State Energie sparen. Alle Teilnehmer beginnen wieder von vorne, im \textit{Discovery-State}, wo sie sich neu synchronisieren. 
\end{itemize}


\subsection{Low Level Radio Driver}\label{sec:LowLevelRadioDriver}

Die Kommunikation über das Radio-Interface wurde mittels einem eigens entwickelten Radio-Driver speziell für die nRF52 / nRF53 SOCs ermöglicht. Dieser stellt die nötigen Funktionen für die P2P Testinfrastruktur zur Verfügung. Zum Beispiel kann die Mode- und Kanalwahl sowie das Senden und Empfangen von Daten mittels simplen Kommandos erfolgen. Bei der Entwicklung diente das \textit{Radio Test Example} \cite{nrf_connect_sdk_radio_test_example_2020} als Vorlage. Der Radio-Driver steuert mithilfe der \textit{NRF-HAL Radio Library} oder über direkten Zugriff auf die Peripherie-Register das Radio-Interface an.

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{nRF52840_Radio_states.png}
	\caption{Radio States \cite{nordic_semi_nrf_infocenter_radio_states_2020}}
	\label{fig:RadioStatesP2P}
\end{figure}

Die Radio Hardware der nRF52 und nRF53 SoCs verfügt über verschiedene Zustände (siehe Abbildung \ref{fig:RadioStatesP2P}). Abhängig von der gewünschten Operation (Senden oder Empfangen) werden die States abgearbeitet.
Um Energie zu sparen, wird nach Abschluss der gewünschten Tätigkeit immer in den Disabled-State gewechselt.
Die Benachrichtigung des Radio Drivers durch die Hardware erfolgt zudem mittels Interrupts, wodurch der Energieverbrauch zusätzlich minimiert werden kann.

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{nRF52840_Radio_Transmit_Sequence_with_Shorts.png}
	\caption{Sende-Ablauf mit Verknüpfungen \cite{nordic_semi_nrf_infocenter_radio_transmit_sequence_2020}}
	\label{fig:RadioTransmitSequP2P}
\end{figure}

Abbildung \ref{fig:RadioTransmitSequP2P} zeigt den Ablauf beim Senden eines Pakets. Die zu sendenden Daten (Payload) müssen vorgängig im RAM vorliegen.
Anschliessend wird der Packet Pointer des Radio-Interface auf die entsprechende Speicher-Adresse eingestellt.
Zu beachten gilt, dass im ersten Byte die Länge der Payload angegeben werden muss.
Diese\todo{Was ist mit DIESE gemeint?} wird vom Radio Driver automatisch ergänzt.
Zusätzlich kann den Sendedaten ein Adressfeld mitgegeben werden. Nach der vollständigen Konfiguration des Radio-Interface wird das Senden durch den Befehl TXEN initiiert. Mithilfe von Verknüpfungen (Shorts) wird nach dem Ready-Event automatisch der Start-Task ausgelöst.
Das Senden läuft also nach dem Initiieren vollautomatisch ab.
Der Radio-Driver wartet auf das Auslösen des Disabled-Events.
Danach ist das Senden erfolgreich abgeschlossen und der Funktionsaufruf kehrt zum Hauptprogramm zurück.

Das Senden mittels CCA wird im \textit{IEEE802.15.4-Mode} unterstützt.
Dazu wird vor dem Senden der Kanal abgehört, um Kollisionen zu vermeiden.
Mittels dem RXEN Befehl wird der CCAStart-Task aktiv. Dieser führt abhängig vom konfigurierten CCA-Modus eine Prüfung des Kanals durch.
Ist der Kanal nicht belegt, wird ein CCAIdle-Event generiert, welcher mittels Verknüpfung automatisch den TXEN-Task startet (siehe Abbildung \ref{fig:CCAIDLEP2P}).
Sendet ein anderer Teilnehmer zum gleichen Zeitpunkt auf diesem Kanal, wird ein CCABusy-Event generiert, welcher ebenfalls den Disable-Task ausführt (siehe Abbildung \ref{fig:CCABUSYP2P}).
Somit enden beide Varianten (Idle und Busy) im Disabled-State, wobei bei Busy Variante keine Daten gesendet werden konnten. \cite{nordic_semi_nrf_infocenter_radio_transmit_sequence_2020}

\begin{figure}[!htbp]
\begin{adjustbox}{width=1\textwidth}
	\begin{minipage}[b]{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{cca.png}
		\caption[Sende-Ablauf mit CCA Idle]{CCA Prüfung (Idle Event)\cite{nordic_semi_nrf_infocenter_radio_ieee_operation_2020}}
		\label{fig:CCAIDLEP2P}
	\end{minipage}
	\begin{minipage}[b]{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{cca_busy.png}
		\caption[Sende-Ablauf mit CCA Busy]{CCA Prüfung (Busy~Event)\cite{nordic_semi_nrf_infocenter_radio_ieee_operation_2020}}
		\label{fig:CCABUSYP2P}
	\end{minipage}
\end{adjustbox}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{nRF52840_Radio_Receive_Sequence_with_Shorts.png}
	\caption{Empfangs-Ablauf mit Verknüpfungen \cite{nordic_semi_nrf_infocenter_radio_receive_sequence_2020}}
	\label{fig:RadioReceiveSequP2P}
\end{figure}


Der Empfangsablauf eines Pakets wird in Abbildung \ref{fig:RadioReceiveSequP2P} dargestellt. Grundsätzlich ist der Ablauf gleich aufgebaut wie beim Senden eines Pakets. Nach dem Initiieren mittels RXEN-Befehl fährt der Empfänger hoch und wartet auf den Empfang eines Pakets. Nach Eingang einer Präambel-Sequenz wird das Adressfeld geprüft.
Dieses kann vorgängig so definiert werden, dass nur Pakete mit übereinstimmender Adresse empfangen werden.
Bei allen BLE-Modes erfolgt die Prüfung auf Hardware-Ebene (ohne Interaktion der CPU).
Beim \textit{IEEE802.15.4-Mode} steht dieses Feature jedoch nicht zur Verfügung. Das Vergleichen des Adressfeldes muss daher der Radio-Driver selbst übernehmen.

Um die Signalstärke (RSSI) des eingehenden Pakets zu messen, wird eine Verknüpfung zwischen dem \textit{Address-Event} und dem \textit{RSSIStart-Task} aktiviert.
Nach erfolgreicher Prüfung der CRC Checksumme wird mittels einer Verknüpfung des CRCOK-Event der Disable-Task ausgeführt.
Beim Empfang eines Pakets wartet der Radio-Driver während eines gewissen Timeouts auf den Disabled-Event.
Die Empfangsfunktion gibt die Restzeit des Timeouts in Millisekunden zurück, wodurch sich ein erfolgreicher Empfang prüfen lässt.
Das Bufferhandling übernimmt der Radio-Driver. Er erwartet beim Senden und Empfangen von Daten eine vordefinierte \textit{Radio-Packet-Structure}.
Es gilt zu beachten, dass die Daten erst nach dem End-Event  vollständig abgearbeitet wurden, da der Zugriff der Hardware via DMA (Direct Memory Access) erfolgt.
Ebenfalls wurde festgestellt, dass beim Wechsel zum oder vom  \textit{IEEE802.15.4-Mode} der Kanalwechsel vor dem Modewechsel erfolgen muss. Ansonsten werden keine Pakete empfangen. \cite{nordic_semi_nrf_infocenter_radio_receive_sequence_2020}


\subsection{Broadcasting Collisions Probability}\label{sec:BroadcastingCollissionsProbability}

Kollisionen entstehen, wenn mehrere Teilnehmer gleichzeitig auf dem selben Kanal (Frequenz) senden.
Dabei stören sich die beiden Sender und es besteht die Möglichkeit, dass der Empfänger keine Daten empfangen kann.
Wenn sich mehrere Teilnehmer neu mit dem Netz verbinden möchten, kann dies ebenfalls zu Problemen führen.
Leider können solche Störungen nicht immer vermieden werden.
In der vorliegenden Anwendung kann ein solcher Fall im Mockup-State entstehend.
Hier soll sich jeder Slave, welcher dem Master noch unbekannt ist, auf die Discovery-Anfrage des Masters melden.
Die Lösung ist, dass jeder Slave einen zufälligen Zeitpunkt zum Antworten auswählt.
Wie gross dieses Zeitfenster sein muss, in welchem ein Slave einen Zeitpunkt zufällig wählen darf, berechnet sich wie folgt:

Angenommen es gibt $N$ Teilnehmer, welche $t_a$ Sekunden brauchen, um eine Antwort zu senden.
Zusätzlich existieren $N_{ch}$ verschiedene Kanäle, auf welchen die Teilnehmer antworten können.
Die Wahrscheinlichkeit, dass sich zwei Sender im Zeitfenster $t_I$ Sekunden nicht überlappen $P_{miss}$, lässt sich gemäss Formel \ref{eq:BroadcastingMissProbability} bestimmen. \cite{rk_how_to_deal_with_broadcasting_collision_2020}

\begin{equation}\label{eq:BroadcastingMissProbability}
P_{miss} = (1- \frac{2 \cdot t_a}{N_{ch}} \cdot t_I)^{N-1}
\end{equation}

Die folgenden Werte wurden zur Berechnung des Zeitfensters im Mockup-State verwendet:

\begin{itemize}
	\item $N = 50$
	\item $t_a = 5ms$
	\item $N_{ch} = 3$
	\item $t_I = 1.2s$	
\end{itemize} 

Somit liegt die Wahrscheinlichkeit, dass alle 50 Nodes sich verfehlen bei 85\%. 

\subsection{Zeitsynchronisation}\label{sec:ZeitsynchronisationP2P}
Die Zeitsynchronisation wurde mittels einer Offset Kompensation gelöst.
Der Zeitgeber (Master) sendet seine Zeit (Timestamp) über einen Broadcast an alle Teilnehmer in der Umgebung.
Die Slaves vergleichen die empfangene Master-Zeit mit ihrer lokalen Zeit und errechnen den Unterschied (Offset) zwischen dem Master-Timestamp und Slave-Timestamp.
Somit können sie ihre Zeit an die des Masters angleichen. Das Prinzip ist relativ simpel, besitzt jedoch einige Ungenauigkeiten. Die Verzögerungszeit zwischen dem Auslesen des Master-Timestamps bis zum Empfangen und Vergleichen mit dem Slave-Timestamp ist kritisch.  

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{Timesync_Basic.png}
	\caption{Zeitsynchronisation über Offset mit Fehler}
	\label{fig:TimesyncBasicwithErrorP2P}
\end{figure}

Wie in Abbildung \ref{fig:TimesyncBasicwithErrorP2P} ersichtlich ist, entsteht ab dem Auslesen der Zeit bis zum Senden eine Verzögerung die TxChainDelay sowie beim Empfänger die RxChainDelay. Das Ziel ist, diese Verzögerungen so gering wie möglich zu halten. 

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{Tiesync_Advanced.png}
	\caption{Zeitsynchronisation über Offset mit PPI}
	\label{fig:TimesyncwithPPIP2P}
\end{figure}

Die Lösung diese Problems wird in Abbildung \ref{fig:TimesyncwithPPIP2P} gezeigt. Der nRF52840 SoC verfügt über ein PPI (Programmable peripheral interconnect) Modul.
Mithilfe des PPI lassen sich verschiedene Events und Tasks direkt Verknüpfen, ohne dass die CPU dabei involviert ist.
Dies führt zu einer minimalen Verzögerung (ca. 1/16$\mu$s) zwischen Event und Task.
Dazu wird der Event, wenn ein Packet erfolgreich gesendet wurde (Radio-End-Event), mit dem Task zum Erfassen des Synctimers (Synctimer-Capture-Task) verknüpft.
Beim Slave wird der Event, wenn ein Packet erfolgreich Empfangen wurde (Radio-CRCOK-Event), mit dem Task zum Erfassen des Synctimers (Synctimer-Capture-Task) verknüpft.
Nach dem Empfang muss der Slave diesen PPI sofort deaktivieren, da ein direkt anschliessendes Paket ebenfalls ein Erfassen des Timers auslöst.
Der Master wird nach der Deaktivierung des PPI mit einem Folgepaket seine Master-Zeit dem Slave mitteilen, welche zum Zeitpunkt des Probe-Packets registriert wurde. Der Slave errechnet den Offset gemäss Formel \ref{eq:TimesyncOffsetSynctimeCalc} und die synchronisierte Zeit gemäss Formel \ref{eq:TimesyncSynctimeCalc}. \cite{nordic_semi_nrf_infocenter_ppi_2020}

\begin{equation}\label{eq:TimesyncOffsetSynctimeCalc}
T_{Offset} =  T_{Master} - T_{Slave} 
\end{equation}

\begin{equation}\label{eq:TimesyncSynctimeCalc}
T_{Sync} =  T_{Slave} + T_{Offset} 
\end{equation}

Zur Verifizierung der Zeitsynchronisation wurde ein Oszilloskop an jeweils einen GPIO-Pin des Masters und an einen Pin des Slaves angeschlossen. Auf dem Master und Slave wurden nacheinander Timer-Interrupts registriert, welche relativ zur synchronisierten Zeit auf dem Master und Slave genau gleichzeitig auslösen. Mithilfe eines PPI-Kanals wurde der Interrupt-Event auf den GPIO-Pin verknüpft.
Beim Auslösen des Interrupts wird der Zustand des GPIO-Pins invertiert.
Dadurch wird die Abweichung präzise auf dem Oszilloskop ersichtlich.

\begin{figure} [H]
	\centering
	\includegraphics[width=1.0\textwidth]{Messungen Timesync (100ns 1200ns).png}
	\caption{Verifizierung Zeitsynchronisation mittels Oszilloskop.}
	\label{fig:TimesyncVerifikationP2P}
\end{figure}

Abbildung \ref{fig:TimesyncVerifikationP2P} zeigt den Signalverlauf der GPIOs von Master (gelb) und Slave (blau).
Anfänglich lagen die Abweichungen im Bereich von ca. 40$\mu$s.
Durch die Wiederholungen der Messung konnte dieser Fehler als systematisch identifiziert werden.
Mithilfe einer Korrektur um 40$\mu$s konnte die Genauigkeit in den Bereich von 100ns bis 1200ns beschränkt werden. Eine Abweichung der Zeitsynchronisation von ca. 1$\mu$s sollte genügend genau sein, damit die Messungen als gute Grundlage für die Statemachine aus Abschnitt \ref{sec:SoftundFirmware} dienen können. 
 
\subsection{Webserver}\label{subsec:DjangoWebserver}
Damit die P2P-Testinfrastruktur visualisiert und mit einem schönen User Interface gesteuert werden kann, wurde ein Webserver aufgesetzt.
Das Ziel ist, auf einem Rechner unter einer Web-Adresse einen Webserver zu erreichen, welche es ermöglicht alle Einstellungen über eine Serielle Schnittstelle dem BMN mitzuteilen.
Damit wird es möglich den Ablauf bequem über den Webserver zu steuern.

\subsubsection{Django}\label{subsubsec:Django}
Als Grundlage für den Webserver dient eine Django Instanz.
Django ist ein open-source Webframework, welches auf dem Model-View-Controller Prinzip basiert und in der Programmiersprache Python geschrieben wurde.
Das Framework hat sein eigenes Benennungssystem für alle Funktionen und Komponenten.
Zum Beispiel werden HTTP-Antworten als Views bezeichnet.
Ein grosser Vorteil von Django ist die Administrationsseite.
Diese ist Bestandteil des Projekts und dient dazu die Models zu verwalten.
Models sind Objekte, die in einer Datenbank des Webservers gespeichert werden. Die gängigsten Datenbanksysteme, wie z.B. SQLLite sind in Django integriert und können aktiviert bzw. implementiert werden \cite{django_django_2020}.
In der Tabelle \ref{table:FeaturesDjango} sind die wichtigsten Features von Django aufgelistet.


\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|} 
\hline
Einfacher Syntax (Python) & Model-View-Controller & Administrations Seite \\ 
\hline
Model-View-Controller & Eigener Webserver & Gängigste Datenbanken \\ 
\hline
HTTP Bibliothek & Python Unit Test Framework & Models für Datenbank \\
\hline
\end{tabular}
\caption{Features Django Webserver \cite{django_django_2020}}
\label{table:FeaturesDjango}
\end{table}

\subsubsection{Software Grundlagen}\label{subsubsec:SoftwareGrundlagen}
Bei einer gewöhnlichen datengesteuerten Webseite wartet die Webanwendung auf eine HTTP-Anfrage des Browsers.
Wird ein Anfrage empfangen, so bestimmt die Anwendung, auf Grundlage der URL, ob ein GET oder POST Event ausgelöst wird.
Je nach Anfrage wird somit aus einer Datenbank gelesen oder es wird in die Datenbank geschrieben.
Die Anwendung sendet danach eine Antwort an den Webbrowser, wobei häufig eine HTML-Seite erzeugt wird, um die Antwort darzustellen. Diese Schritte sind in Django, wie in der Abbildung \ref{fig:DjangoAblauf} aufgeführt, in separaten Dateien zusammengefasst. Dies werden unterhalb kurz beschrieben.

\begin{figure} [H]
	\centering
	\includegraphics[width=0.76\textwidth]{Django Ablauf.png}
	\caption{Django Funktionen \cite{mdn_web_docs_django_2019}}
	\label{fig:DjangoAblauf}
\end{figure}

\paragraph{URLs}
Die URL Datei leitet die Anfrage an die entsprechende View weiter. Damit dies gelingt wird ein URL-Mapper eingesetzt.
Dieser dient dazu, die Anfrage so zu interpretieren, damit die richtige View aufgerufen wird.
Zusätzlich erkennt der URL-Mapper Zeichenketten und Ziffern in der URL und kann diese abgleichen und anschliessend als Daten an die View-Funktion weitergeben.

\paragraph{Views}
Die View ist eine Request-Handler-Funktion, die HTTP-Anfragen empfängt und zurückgibt.
Die View kann über die Model Funktion auf Daten in der Datenbank zugreifen.
Über die Template-Funktion beschreibt die View schlussendlich, wie die HTTP-Antwort formatiert werden muss.

\paragraph{Models}
Ein Model ist ein Python Objekt, welches die Struktur der Daten einer Anwendung definiert. Darüber hinaus stellt die Funktion die Mittel wie beispielsweise das Hinzufügen, Löschen oder Ändern bereit, um die Daten in der Datenbank zu verwalten.
Die Model Funktion ist somit die Schnittstelle zur Datenbank.

\paragraph{Templates}
Das Template ist eine Textdatei, in der die Struktur oder das Layout einer zugehörigen HTML-Seite definiert wird.
Für die Struktur werden Platzhalter zur Darstellung des eigentlichen Inhalts verwendet.
Demnach kann die View-Funktion mit Hilfe vom Templates eine dynamische HTML-Seite erzeugen und diese mit Daten der Model-Funktion füllen.

\subsubsection{Aufbau Software}\label{subsubsec:SoftwareAufbau}
Der Aufbau des Django Weberservers für die P2P-Testinfrastruktur ist in Abbildung \ref{fig:FunktionenP2PWebserver} ersichtlich.

\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\textwidth]{DjangoSoftwaredoku.png}
	\caption{Funktionen P2P Webserver}
	\label{fig:FunktionenP2PWebserver}
\end{figure}


\paragraph{URLs}
In der folgenden Tabelle sind alle URLs aufgelistet, welche verwendet wurden, um auf die entsprechenden Views zu verweisen.

\begin{itemize}
	\item 127.0.0.1:8000/node\textunderscore list \hspace{2.5mm} referenziert auf die View node\textunderscore list
	\item 127.0.0.1:8000/chart \hspace{10mm} referenziert auf die View chart
	\item 127.0.0.1:8000/connect \hspace{6mm} referenziert auf die View connect
	\item 127.0.0.1:8000/info \hspace{12.5mm} referenziert auf die View info
\end{itemize} 

\paragraph{Views}
Es wurden vier Views im P2P-Webserver erstellt, die die Schnittstellen zu den Forms, den Models und den HTML-Dateien bilden:
\begin{itemize}
	\item node\textunderscore list
	\item chart
	\item connect
	\item info
\end{itemize} 
Die Bedienung der einzelnen Seiten wurde im Kapitel \ref{sec:InbetriebnahmeBedienungP2P} bereits erläutert.

\paragraph{Models}
Für die Speicherung der Daten vom P2P Master sind die folgenden zwei Objekte verfügbar: 
\begin{itemize}
	\item Node
	\item Channel
\end{itemize} 

Diese zwei Objekte sind miteinander verknüpft.
Wenn ein Objekt Node erstellt wird, können die dazugehörigen Channel Informationen ebenso erstellt werden.
Dadurch ist eine klare Struktur gegeben.
Über das Objekt Node können die verschiedenen Channel Informationen abgerufen werden.

Folgende Parameter können dem Objekt Node als Information mitgegeben werden:
\begin{itemize}
	\item MAC Adresse
\end{itemize} 

Folgende Parameter können dem Objekt Channel als Information mitgegeben werden:
\begin{itemize}
	\item Channel Nummer
	\item Signal to noise ratio
	\item Packetloss
	\item Node ID
\end{itemize}

\paragraph{Templates}
Als Template wurden zwei verschiedene Django Forms erstellt. Die eine Form ist eine Anordnung an Eingabefeldern, die frei bestimmt werden können. Die Dropdown Auswahlmöglichkeiten sind in der Tabelle \ref{table:TabelleAuswahlfelder} aufgelistet.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|} 
\hline
\multicolumn{4}{|c|}{\textbf{Auswahlfelder} } \\ 
\hline
\multicolumn{1}{|c|}{\textbf{Mode} } & \multicolumn{1}{c|}{\textbf{CSMA CA} } & \multicolumn{1}{c|}{\textbf{Tx Power} } & \multicolumn{1}{c|}{\textbf{Port} } \\ 
\hline
1 Mbit/s Nordic radio mode & Off & 0 dB & Disconnect \\ 
\hline
2 Mbit/s Nordic radio mode & Ed Mode & 1 dB & COM 1 \\ 
\hline
1 Mbit/s BLE & Carrier Mode & 2 dB & COM 2 \\ 
\hline
2 Mbit/s BLE & Carrier and Ed Mode & 3 dB & COM 3 \\ 
\hline
Long range 125 kbit/s TX & Carrier or Ed Mode & 4 dB & COM 4 \\ 
\hline
Long range 500 kbit/s TX &  & 5 dB & COM 5 \\ 
\cline{1-1}\cline{3-4}
IEEE 802.15.4-2006 250 kbit/s &  & 6 dB & COM 6 \\ 
\cline{1-1}\cline{3-4}
\multicolumn{1}{l}{} &  & 7 dB & COM 7 \\ 
\cline{3-4}
\multicolumn{1}{l}{} &  & 8 dB & \textbf{...}  \\
\cline{3-4}
\end{tabular}
\caption{Tabelle Auswahlfelder}
\label{table:TabelleAuswahlfelder}
\end{table}


Für die Eingabe der Parameter, die auf dem P2P Master eingestellt werden können, ist die Form \textit{ParamForm} mit folgenden Eingabefeldern verfügbar:
\begin{itemize}
	\item Start Channel \hspace{5mm} -> Integer Feld
	\item Stop Channel \hspace{6mm} -> Integer Feld
	\item Size \hspace{22.3mm} -> Integer Feld
	\item Mode \hspace{19.5mm} -> Drop Down Auswahlfeld
	\item CSMA CA \hspace{10.5mm} -> Drop Down Auswahlfeld
	\item Tx Power \hspace{13mm} -> Drop Down Auswahlfeld
\end{itemize}

Für die Auswahl des Ports der Seriellen Verbindung zum Master ist die Form \textit{ParamForm} mit folgenden Eingabefeldern verfügbar:
\begin{itemize}
	\item  Port \hspace{22mm} -> Drop Down Auswahlfeld
\end{itemize}

In Abbildung \ref{fig:ParamForm} und \ref{fig:PortForm} sind die Eingabe Forms ersichtlich. Die Daten werden mit einem Button, der ein HTTP-POST Ereignis auslöst, an die entsprechende View weitergeleitet.

\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\textwidth]{ParamForm.png}
	\caption{Parameter Form}
	\label{fig:ParamForm}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.3\textwidth]{PortForm.png}
	\caption{Port Form}
	\label{fig:PortForm}
\end{figure}

\paragraph{Serielle Kommunikation:}
Die serielle Kommunikation wird mithilfe der Python Bibliothek \textit{PySerial} aufgebaut. Auf der P2P-Webserver Seite Connect kann der Port ausgewählt werden, an dem der P2P-Master angeschlossen ist. Sobald die Verbindung zum Master besteht, wird ein separater Python Thread gestartet. In diesem Thread wird in einem while-loop das Serielle Interface permanent ausgelesen. Sobald der Master einen neuen Mess-Report schickt, wird dieser ausgewertet und die Objekte Node und Channel werden anhand des Reports erstellt. In Abbildung \ref{fig:AblaufDjangoSerial} ist dieser Ablauf ersichtlich.

Die erhaltenen Daten werden in der View Node\textunderscore List in einer dynamischen Tabelle, die jede Sekunde aktualisiert wird, angezeigt. Zudem ist in der View Chart eine Visualisierung der Daten ersichtlich. Die Messergebnisse werden mit Hilfe der Bibliothek \textit{PlotLy} dargestellt. 

\begin{figure} [H]
	\centering
	\includegraphics[width=0.63\textwidth]{Ablauf Django Serial.png}
	\caption{Ablauf Django Serial}
	\label{fig:AblaufDjangoSerial}
\end{figure}

\newpage
\section{Schluss}\label{sec:SchlussP2P}

Abschliessend wird eine kurze Validierung und Verifizierung der Messresultate, sowie ein Fazit vorgenommen.

\subsection{Validierung}\label{subsec:P2PValidierung}
Die vorgegebenen Ziele zur Erfassung des SNR und Paketverlusts konnten erreicht werden.
Das Tool erfüllt mittels der grafischen Oberfläche seinen Zweck als universell einsetzbares Messwerkzeug.
Das Erfassen des SNRs funktioniert jedoch nicht immer optimal.
Durch Störeinflüsse, welche sich schnell ändern (WLAN etc.) kann es vorkommen, dass die Angabe des SNRs nicht korrekt erfolgt.
Die Ergebnisse des Paketverlusts sehen allerdings valide aus. 

\todo[inline]{Cyrill: Validierung ausführlicher oder ganz weglassen.}

\todo[inline]{Was hätte am Konzept verbessert werden können?}
\todo[inline]{Evtl. RSSI aus Mesh Test mit SNR vergleichen.}
\todo[inline]{Webserver Wahl Django richtig oder falsch.}
\todo[inline]{Test der Plattform erfolgreich}


\subsection{Verifizierung}\label{subsec:P2PVerifizierung}
Die Messwerte korrelieren mit denjenigen des Radio-Test-Examples, welches einen ähnlichen Zweck erfüllt \cite{nrf_connect_sdk_radio_test_example_2020}.
Die Messresultate sind jedoch stark von äusseren Störeinflüssen abhängig. Somit wird eine exakte Verifizierung fast unmöglich.

\todo[inline]{Cyrill: Verifizierung ausführlicher oder ganz weglassen.}

\todo[inline]{Kontrolle mit Messgeräte wäre möglich. Messgerät ist aber nicht vorhanden daher nicht möglich.}


\subsection{Fazit}\label{subsec:FazitP2P}
\paragraph{Firmware}
Die Analyse des MAC-Layers und die Umsetzung der Testinfrastruktur hat viele Erkenntnisse im Bereich der hardwarenahen Programmierung gebracht. Durch die Erarbeitung der Firmware sind viele Module (Zeitsynchronisation, Statemachine, CLI, etc.) geschaffen worden, welche in weitere Programme integrierbar sind. Somit ergab sich eine optimale Grundlage, um in die Netzwerk-Stacks, welche auf dem MAC-Layer basieren, einzutauchen.

\paragraph{Webserver}
Die Entwicklung eines Webservers für die Bedienung der P2P-Testinfrastruktur war eine sehr lehrreiche Erfahrung. Bis anhin waren nur die Programmiersprachen C und C\texttt{++} bekannt. Das Erlernen und Anwenden von Python, HTML und Javascript für den Aufbau und die Darstellung des Webservers waren sehr intensiv aber auch lehrreich. Gewisse Funktionen vom Webserver könnten verbessert werden. Dazu gehören folgende:

\begin{itemize}
	\item Das Aktualisieren der Tabellen und der Charts wird im Sekundentakt gemacht. Es wäre besser die Aktualisierung auszuführen sobald der Master Node meldet, dass er mit dem Report fertig ist.
	\item Das Aktualisieren der Charts geschieht, indem die ganze Seite neu geladen wird. Die einzelnen Charts neu zu zeichnen, ohne die Seite neu zu laden, wäre effektiver.
	\item Die Auswahl des COM-Ports ist fix hinterlegt. Eine dynamische Auswahl, die zeigt welche Geräte angeschlossen sind, wäre in der Bedienung komfortabler.
\end{itemize}


