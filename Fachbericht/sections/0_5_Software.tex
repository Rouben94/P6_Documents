\clearpage
\section{Soft- und Firmware}\label{sec:Soft-undFirmware}


Im folgenden Abschnitt werden Anforderungen, Konzept und die Umsetzung der Software dokumentiert. Die Lösungsfindung und ihre Prozess wird nachfolgend beschrieben. 

\subsection{Anforderungen}\label{subsec:Software_Anforderungen}

Wie bereits im Abschnitt \ref{subsec:VergleichswerteundMessgrössenMesh} wurden die Anforderungen in der Aufgabenstellung (siehe Anhang \ref{app:Aufgabenstellung}) sowie im Pflichtenheft (siehe Anhang \ref{app:Pflichtenheft}) vorgängig festgelegt. Im Fokus steht das erfassen der wichtigsten Messgrössen welche bereits in Abschnitt \ref{subsec:VergleichswerteundMessgrössenMesh} definiert wurden. 

Die Erfassung der Messwerte muss in allen Mesh-Netzwerken möglich sein. Um die Messresultate vergleichen zu können müssen die gleichen Ausgangslagen vorliegen, sowie die selben Messmethoden angewendet werden. 


\subsection{Konzept}\label{subsec:Software_Konzept}

Das Konzept der Messung wurde in Abschnitt \ref{sec:BenchmarkKonzeptMeshNetzwerke} erläutert. Die Software soll so aufgebaut sein, dass sie von allen Mesh-Stacks genutzt werden kann. Zur Umsetzung der Mesh-Stacks mittles der \textit{NRF-Platform} sind folgende SDKs vorhanden: 

\begin{itemize}
	\item \textit{\textbf{nRF Connect SDK}}: Auf dem Zephyr-RTOS aufbauende SDK. Diese soll in Zukunft alle drei Mesh-Protokolle (Bluetooth-Mesh, Openthread und Zigbee) unterstützen. Wird jedoch noch nicht zum Einsatz in End-Produkten empfohlen. \cite{nordic_semi_welcome_to_the_nrf_connect_sdk_2020}
	\item \textit{\textbf{nRF SDK for Thread and Zigbee}}: Proprietäre SDK Library von Nordic Semiconductor. Thread integration mittels Openthread, Zigbee einbindung mittels ZBOSS. \cite{nordic_semi_nrf_sdk_for_thread_and_zigbee_2020}
	\item \textit{\textbf{nRF SDK for Mesh}}: Proprietäre SDK Library von Nordic Semiconductor für Bluetooth-Mesh. Ist zur Produktion freigegeben. \cite{nordic_semi_nrf_sdk_for_mesh_2020}
\end{itemize}

Die Messungen sollten trotz der verschiedenen Bibliotheken möglichst einheitlich sein, um die Vergleichbarkeit nicht zu beeinträchtigen. Um eine möglichst unabhängig von der verwendeten Library zu sein, wurde auf eine selbst entwickelte Kommunikation über die P2P-Testinfrastruktur gesetzt. 


\subsection{Umsetzung}\label{subsec:Software_Umsetzung}


Die Software und Firmware für die Mesh Benchmarks setzt sich aus diversen Modulen zusammen. Die Tabelle \ref{tab:UebersichtSoftware} zeigt eine Übersicht der wichtigsten Module und deren Verwendung in den 3 Benchmark Teilen: BLE Mesh, Thread und Zigbee.
Gemeinsame Module auf Firmware Ebene sind im Ordner SharedLib im Github Repository\footnotemark\ zusammengefasst.

Jene Python Scripts für das Benchmark Management stehen im gleichnamigen Ordner auf dem Github Repository zur Verfügung.
Die Stack bezogenen Implementationen der Benchmark Firmware werden in den individuellen Teilen \ref{part:BluetoothMesh}, \ref{part:Thread} und \ref{part:Zigbee} behandelt.


%\newcommand{\rotcells}[1]{%
%  \rotatebox[origin=c]{90}{ #1 }%
%}

\begin{table}
\centering
\caption{Übersicht Shared Lib und Benchmark Management Module}
\label{tab:UebersichtSoftware}
\begin{tabular}{|l|l|l|c|} 
\hline
Library & Funktion & Modul & Referenz \\ 
\hline
\multirow{8}{*}{SharedLib} & Statemachine & bm\_statemachine.c & \ref{subsubsec:StatemachineSoftware} \\ 
\cline{2-4}
 & Timesync & bm\_timesync.c & \ref{subsubsec:Timesync}  \\ 
\cline{2-4}
 & Control & bm\_control.c & \ref{subsubsec:Control} \\ 
\cline{2-4}
 & Report & bm\_report.c & \ref{subsubsec:Report} \\ 
\cline{2-4}
 & Logging & bm\_log.c & \ref{subsubsec:Logging} \\ 
\cline{2-4}
 & Flash Save & bm\_flash\_save.c & \ref{subsubsec:FlashSave} \\ 
\cline{2-4}
 & CLI & bm\_cli.c & \ref{subsubsec:CLI} \\ 
\cline{2-4}
 & Low Layer Radio & bm\_radio.c & \ref{subsubsec:LowLevelRadio} \\ 
 \cline{2-4}
 & Random and Sequential Traffic Generator & bm\_rand.c & xy \\ 
\hline
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\ 
\hline
\multirow{4}{*}{\begin{tabular}[c]{@{}l@{}}Benchmark\\Management \end{tabular}} & Flash & Flasher.py & xy \\ 
\cline{2-4}
 & Configurator & Configurator.py & xy \\ 
\cline{2-4}
 & Benchmark & \begin{tabular}[c]{@{}l@{}}Benchmark\_and\_\\Reporter.py \end{tabular} & xy \\ 
\cline{2-4}
 & Analysis & Analysis.py & xy \\ 
\hline
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\ 
\hline
\multirow{2}{*}{BT Mesh} & Stack Handling & bm\_blemesh.c & \ref{sec:BTMeshUmsetzungBenchmark} \\ 
\cline{2-4}
 & Stack Configuration & bm\_config.c & \ref{sec:BTMeshUmsetzungBenchmark} \\ 
\hline
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\ 
\hline
\multirow{2}{*}{Thread} &  &  & \ref{sec:ThreadUmsetzungBenchmark} \\ 
\cline{2-4}
 &  &  & \ref{sec:ThreadUmsetzungBenchmark} \\ 
\hline
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\ 
\hline
\multirow{2}{*}{Zigbee} & Stack Handling & bm\_zigbee.c & \ref{sec:ZigbeeUmsetzungBenchmark} \\ 
\cline{2-4}
 & Stack Configuration & bm\_config.c & \ref{sec:ZigbeeUmsetzungBenchmark} \\
\hline
\end{tabular}
\end{table}


Sämtliche Firm- und Software Komponenten die für Mesh Benchmark sowie die P2P Testinfrastruktur nötig sind, können auf dem Github Repository zum Projekt unter folgendem \href{https://github.com/Rouben94/P6_Software}{Link\footnotemark[\value{footnote}]}  eingesehen werden. Die nächsten Abschnitte behandeln die Umsetzung der Software, welche von allen Mesh-Stacks genutzt wird.

\footnotetext{\url{https://github.com/Rouben94/P6_Software} \cite{anklin_bobst_horath_rouben94p6_software_nodate}}




\subsection{Shared Library}\label{subsec:SharedLibrary}

Die \textit{Shared Library} ist die geteilte Bibliothek zwischen allen Mesh-Stacks. Sie beherbergt alle relevanten Module um eine Messung zu Verwalten. Der jeweilige Mesh-Stack ist lediglich für das senden und empfangen von Nachrichten, sowie zum Erfassen der Messdaten zuständig. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Shared_Lib_Concept.png}
	\caption{Vereinfachte Anbindung der \textit{Shared Library} an die Mesh-Stacks}\label{fig:ShardeLibConcept}
\end{figure}

Abbildung \ref{fig:ShardeLibConcept} zeigt die vereinfachten Schnittstellen zwischen der Shared-Library und den Mesh-Stacks. Die Bibliothek ist spezifisch für die nRF52840 SOCs zugeschnitten. Um einfach in die jeweilige SDK integrierbar zu sein müssen die Module der Shared-Lib möglichst ohne weitere Abhängigkeiten klar kommen. Sofern Treiber oder externe Bibliotheken für Module benötigt werden, müssen diese von allen SDKs vergleichbar zur Verfügung gestellt werden. Im folgenden Abschnitt wird auf die einzelnen Module der \textit{Shared-Lib} eingegangen. 


\subsubsection{Statemachine}\label{subsubsec:StatemachineSoftware}

Die Statemachine dient dazu den Ablauf, welcher in Abschnitt \ref{subsec:AblaufMesh} beschrieben wurde abzuarbeiten. Sowohl der Master, die Server und Clients arbeiten den in Abbildung \ref{fig:StatemachineFLowgraph} dargestellten Ablauf ab. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{Statemachine_Flowgraph.png}
	\caption{Flowgraph der Statemachine}\label{fig:StatemachineFLowgraph}
\end{figure}


Die Funktion der Schritte wird im Folgenden grob beschrieben. Zur genauen Untersuchung ist der Source Code unter \cite{rouben94_sharedlib_software_git_2020} verfügbar.  \\

\begin{itemize}
	\item \textbf{\textit{Init:}} Dieser Schritt initialisiert alle notwendige Funktionen (Radio, Timers, usw.). Ebenfalls rekonstruiert er die \textit{Log-Daten} indem er diese aus dem Flash in das RAM kopiert. Nach der erfolgreichen Initialisierung wechselt die Statemachine in den Control-State.
	\item \textbf{\textit{Control:}} Im Control-State wartet jeder Teilnehmer auf eingehende Befehle des Benutzers. Der Master erhält über das Command Line Interface (CLI) den auszuführenden Befehl. Diesen wandelt der Master in eine Nachricht (Control-Message) um und leitet sie über das Radio-Interface an die Slaves weiter.  Alle Slaves (Clients und Servers) erwarten eine Control-Message über das Radio-Interface. Damit alle Clients und Servers die Nachricht empfangen können wiederholt jeder Slave jede Control-Message. Somit wird die Mesh-Fähigkeit der Verwaltungsschicht (Benchmark Managment) sichergestellt. Folgende Transitionen sind vom Control-State zugelassen: 
	\begin{itemize}
		\item \textit{\textbf{Transition to Timesync}}: Wird ein Benchmark gestartet erfolgt dies durch einen Wechsel in den Timesync-State. Jeder Teilnehmer wechselt nach wiederholen der Nachricht in den entsprechenden Schritt. 
		\item \textit{\textbf{Transition to Report}}: Das Reporting wird über den Report-State abgehandelt. Nur der Teilnehmer von welchem Reports angefordert wurden, wechselt in den Report-State. 
	\end{itemize} 	
	\item \textbf{\textit{Timesync:}} Der Master verteilt die Zeitsynchronisation an die Slaves. Die Slaves synchronisieren sich auf das Signal des Masters auf, sofern sie in seiner Reichweite liegen. Sobald ein Slave synchronisiert ist, fängt er an die Zeitsynchronisation ebenfalls zu verteilen. Dadurch können Slaves, welche nicht über einen Hop vom Master erreicht werden sich ebenfalls synchronisieren. Konnte ein Slave keine Zeitsynchronisation durchführen, wechselt dieser in den  \textit{Control-State} zurück und bringt einen Fehler mittels der roten-LED zur Anezige. Der Master wird immer zum nächsten Schritt voranschreiten. 	
	\item \textbf{\textit{Init Benchmark:}} Dies ist der Zeitpunkt bei welchem jeder Teilnehmer den Mesh Stack-Initialisiert und Anschliessend Startet. Das Netzwerk hat nun Zeit sich aufzubauen, falls dies notwendig ist. Vor dem Initialisieren des Mesh-Stacks löscht jeder Node die Log-Daten aus dem Flash, sowie dem RAM. Beim Client wird zusätzlich der Sendezeitpunkt der Benchmark-Nachrichten (Benchmark-Messages) berechnet und vorbereitet. Hat sich der Slave erfolgreich Initialisiert und mit dem Netzwerk verbunden, beginnt das grüne Status-LED zu leuchten. Der wechsel zum Benchmark-State wird unabhängig vom Verbindungsstatus nach einer Verzögerungszeit ausgelöst. 
	\item \textbf{\textit{Benchmark:}} Die Statemachine wartet in diesem Schritt lediglich auf das auslösen von Events. Beim Server überlässt sie dem Mesh-Stack das Loggen der empfangenen Nachrichten, welcher über einen eigenen Event-Handler verfügt. Beim Client plant die Statemachine das senden von Nachrichten mittels Timer-Interrupts. Löst ein solcher aus, wird der Mesh-Stack sofort benachrichtigt. Das erfassen des Logs erfolgt ebenfalls im Stack. Der Status des einzelnen Slaves (Licht EIN / Aus) ist über die grüne RGB-LED (Client) oder die blaue RGB-LED (Server) erkennbar. Nach der eingestellten Benchmark-Zeit, löst der Letzte Timer-Interrupt aus und die Abarbeitung des Mesh-Stacks wird abgebrochen. Es folgt der wechsel zum letzten Schritt. 
	\item  \textbf{\textit{Save Flash:}} Das speichern der Log-Daten aus dem RAM in das Flash ist unabdingbar, damit diese persistent bleiben. Anschliessend wird der Mesh-Stack durch einen Reset des Mikrocontrollers heruntergefahren. Dies ist notwendig um sicherzustellen, das der Stack komplett deinitialisiert ist und das Radio-Interface für das Benchmark-Management zur verfügung steht. Zudem soll ein neuer Benchmark ohne Vorbelastung möglich sein. Nach dem Reset beginnt die Statemachine automatisch wieder von vorne im Init-State. 
	\item  \textbf{\textit{Reports:}} Das einholen von Reports ist nur über eine direkte Verbindung vom Master zum Slave möglich. Die Übertragung der Log-Einträge erfolgt über ein abgesichertes Handshake-Verfahren. Der Master sendet eine Anfrage und verlangt beim Slave den n-ten Log-Eintrag. Der Slave antwortet auf die Anfrage mit dem entsprechenden Log-Eintrag. Hat der Master diesen erhalten, so verlangt er den nächst höheren Eintrag. Andernfalls verlangt der Master den selben Eintrage erneut. Ist die Übetragung zu oft fehlgeschlagen wird das Reporting abgebrochen. Der Master und Slave wechseln beide nach erfolgreichem oder abgebrochenem Reporting in den Control-State zurück.  
\end{itemize}

\subsubsection{Timesync}\label{subsubsec:Timesync}

Die Zeitsynchronisation wurde identisch wie in Abschnitt \ref{sec:ZeitsynchronisationP2P} umgesetzt. Durch wiederholen der Master-Timestamps, nimmt der Synchronisationsfehler pro Hop zu. Angenommen pro Hop entstehen maximal 1.2us, so wäre der maximale Fehler nach sieben Hops 8.4us. Dieser Fehler ist vernachlässigbar klein veglichen mit dem Clock-Drift. Die genauigkeit des Quarz-Oszilators auf dem nRF52840 liegt bei +/- 10ppm. Das heisst pro Sekunde kann ein maximaler Clock-Drift von 20us entstehen. 

Um die Funktionen von Master und Slave zu unterscheiden, wurde eine Subscribe- und Publish-Funktion definiert. Der Master verteilt den Timestamp über die Publish-Funktion. Der Slave Subcribet auf Timesync-Paket. Erhält der Slave ein Timesync-Paket, wiederholt dieser das Frame mittels der Publish-Funktion. Vor dem Publishen muss immer einen zufälligen Timeslot abgewartet werden, damit es nicht zu Kollisionen zwischen den Timesync-Paketen kommt. Die maximale Backoff-Zeit kann gemäss Abschnitt \ref{sec:BroadcastingCollissionsProbability} berechnet werden. Entsprechend muss das Zeitfenster zur Synchronisation genügend lang sein, damit alle Teilnehmer sich synchronisieren können.\\

Ein Timesync-Pakete setzt sich aus folgenden Feldern zusammen. 

\begin{itemize}
	\item \textit{uint64\_t} \textbf{LastTxTimestamp} Gibt den Zeitstempel (Master-Zeit) an welcher zum Zeitpunkt des versandt des Probepakets erfasst wurde. \\
	\item \textit{uint64\_t} \textbf{NextState\_TS\_us} Definiert den Zeitpunkt um in den nächsten Schritt zu wechseln.\\
	\item \textit{uint32\_t} \textbf{MAC\_Address\_LSB} Die Identifizierung des Time-Masters. Muss mit dem des vorherigen empfangenen Paket übereinstimmen. \\
	\item \textit{uint8\_t} \textbf{seq} Sequenz-Feld zur Überprüfung ob das vorherige Timesync-Paket des Time-Masters das zuletzt versendete war. \\
\end{itemize}

Der Source Code ist zur genaueren Untersuchung online\footnotemark\ verfügbar. 

\footnotetext{\url{https://github.com/Rouben94/P6_Software/blob/master/SharedLib/bm_timesync.c} \cite{rouben94_sharedlib_timesync_software_git_2020}}

\subsubsection{Control}\label{subsubsec:Control}

Im Control-State befinden sich alle Teilnehmer in Bereitschaft (wie bereits in Abschnitt \ref{subsubsec:StatemachineSoftware} beschrieben). Es wurden wie in Abschnitt \ref{subsubsec:Timesync} Publish- und Subscribe-Funktionen definiert um Control-Messages zu verteilen. Eine Control-Message beinhaltet die wichtigsten folgenden Felder.

\begin{itemize}
	\item \textit{uint32\_t} \textbf{MACAddressDst} Control-Messages erfüllen den Zweck den Zustand eines Teilnehmers oder den aller Teilnehmer zu ändern. Dazu wurde dieses Feld als Ziel MAC-Adresse festgelegt. Die MAC-Adresse 0xFFFFFFFF ist als Broadcast defniert. \\
	
	\item \textit{uint8\_t} \textbf{depth} Die Anzahl Relays, welche die Nachricht bereits absolviert hat. Der Master sendet immer mit der Tiefe 0. Wird ein Paket Relayed (Wiederholt) wird das Depth-Feld um eins erhöht. Erreicht ein Paket mit einer höheren Tiefe als die zuletzt empfangene Tiefe, so wird das Paket nicht erneut gesendet. Die zuletzt empfangenen Tiefe ist nur eine gewisse Zeit gültig um auf Veränderungen im Netzaufbau reagieren zu können. \\
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{Control_Hops.png}
		\caption{Konzept des Depth-Feld beim versenden einer Control-Message}\label{fig:ControlMessagesHops}
	\end{figure}

	Abbildung \ref{fig:ControlMessagesHops} zeigt die Verbreitung einer Controll-Message mithilfe des Depth-Feldes. \\
	
	\item \textit{div.} \textbf{Control-Paramter} Die restlichen Felder sind Parameter, welche den Zustand des Nodes verändern oder Parameter übergeben. 
\end{itemize}


Ein Teilnehmer signalisiert über aufblinken der grünen-LED seine Bereitschaft um weiter Control-Messages verarbeiten zu können. Blinkt die blaue-LED auf zeigt dies an das der Teilnehmer eine Zustands- oder Parameteränderung erhalten hat. 

Das abfragen von Control-Messages erfolgt durch Pollen. Dies hat den Ursprung, das nicht bei allen SDKs der Interrupt des Radio-Interfaces frei ist. (siehe Abschnitt ...). 


Der Source Code ist zur genaueren Untersuchung online\footnotemark\ verfügbar. 

\footnotetext{\url{https://github.com/Rouben94/P6_Software/blob/master/SharedLib/bm_control.c} \cite{rouben94_sharedlib_cotrol_software_git_2020}}




\subsubsection{Report}\label{subsubsec:Report}

Wie bereits in Abschnitt \ref{subsubsec:StatemachineSoftware} beschrieben werden vom Master anfragen an einen Slave getätigt um dessen Reports einzuholen. Dazu wird eine Control-Message vom Master initiiert um den Slave in den Reporting Zustand zu versetzten. Diese Nachricht wird zwar Relayed, jedoch funktioniert das anschliessende Reporting nur über eine direkte Verbindung. \\

Das Reporting teilt sich in eine Subscribe und Publish-Funktion auf. Der Master Subcribed auf Reports und sendet Reports-Requests an den Slave. Der Slave erwartet in der Publish-Funktion Report-Requests des Masters. Erhält ein Slave einen Request, so sendet er darufhin dem Master den verlangten Eintrag dem Master zu. \\

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{Reporting_Flowchart.png}
	\caption{Ablauf des Reportings mit Handshake zwischen Master und Slave}\label{fig:ReportingAblauf}
\end{figure}

Die Abbildung \ref{fig:ReportingAblauf} zeigt den Ablauf des Reportings beispielhaft. Durch das Handshake verfahren, wie bereits in Abschnitt \ref{subsubsec:StatemachineSoftware} beschrieben, wird der Repoert-Entry 2 nochmals angefordert, da dieser nicht erfolgreich beim Master angekommen ist. 


\subsubsection{Logging}\label{subsubsec:Logging}

\subsubsection{Flash Save}\label{subsubsec:FlashSave}

\subsubsection{CLI}\label{subsubsec:CLI}

\subsubsection{Low Level Radio}\label{subsubsec:LowLevelRadio}


\subsection{Benchmark Management}\label{subsec:Benchmark Management}

\subsubsection{Flash}\label{subsubsec:Flash}

\subsubsection{Configurator}\label{subsubsec:Configurator}

\subsubsection{Benchmark}\label{subsubsec:Benchmark}

\subsubsection{Analysis}\label{subsubsec:Analysis}

